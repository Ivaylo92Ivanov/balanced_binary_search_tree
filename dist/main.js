(()=>{const t=(e,l="",o=!0)=>{null!==e&&(null!==e.right&&t(e.right,`${l}${o?"│   ":"    "}`,!1),console.log(`${l}${o?"└── ":"┌── "}${e.data}`),null!==e.left&&t(e.left,`${l}${o?"    ":"│   "}`,!0))};class e{constructor(t,e=null,l=null){this.data=t,this.left=e,this.right=l}}function l(t){if(t.length<1)return null;if(1==t.length)return new e(t[0]);let o=new Set(t);(t=Array.from(o)).sort(((t,e)=>t-e));let r=Math.floor(t.length/2),n=t[r],i=t.slice(0,r),s=t.slice(r+1),a=l(i),h=l(s);return new e(n,a,h)}let o=new class{constructor(o){this.arr=o,this.root=l(o),this.insert=o=>{if(null==this.root)return void(this.root=l([o]));let r=this.root;for(;;){if(o==r.data)return void console.log(`Value "${o}" already in Tree`);if(o<r.data){if(console.log(`the value ${o} is smaller than ${r.data}, so moving left.`),!r.left){r.left=new e(o);break}r=r.left}else{if(console.log(`the value ${o} is bigger than ${r.data}, so moving  right.`),!r.right){r.right=new e(o);break}r=r.right}}t(this.root)},this.delete=t=>{console.log(`Delete value: ${t}`)}}}([]);o.insert(5),o.insert(9),o.insert(1),t(o.root),console.log(o.root)})();